{"createdAt":"2025-10-03T16:04:00.258Z","updatedAt":"2025-10-03T22:08:30.740Z","id":"p0pZuoGt8Vj7rxwI","name":"ResolveCardapio","active":false,"isArchived":false,"nodes":[{"parameters":{"workflowInputs":{"values":[{"name":"empresa_id","type":"number"},{"name":"texto"},{"name":"categoria"},{"name":"topn","type":"number"},{"name":"min_score","type":"number"},{"name":"user_id","type":"number"},{"name":"pedido_id","type":"number"}]}},"type":"n8n-nodes-base.executeWorkflowTrigger","typeVersion":1.1,"position":[-864,-48],"id":"e64f2dd2-317e-43de-9369-ab98bd991bc0","name":"When Executed by Another Workflow"},{"parameters":{"jsCode":" function norm(s){return (s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().trim();}\nconst texto = norm(  $input.first().json.comandos|| '');\nconst mNum = texto.match(/\\b\\d{1,3}\\b/);\nconst isNumero = !!mNum;\n\nreturn [{\n  json: {\n    empresa_id: $json.empresa_id,\n    texto: $input.first().json.nome,\n    isNumero,\n    numero: isNumero ? Number(mNum[0]) : null,\n    categoria: $json.categoria ?? null,\n    topn: $json.topn ?? 5,\n    min_score: $json.min_score ?? 0.35\n  }\n}];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[848,-32],"id":"d365a54c-1c04-4235-a652-bcfcb85ed237","name":"Code"},{"parameters":{"jsCode":" // Sai SEMPRE um único objeto com:\n// {\n//   normalizado, is_numero, total,\n//   itens: [{numero,nome,categoria,tipo,valor,score, quantidade, tamanho}],\n//   linhas: \"numero|nome|categoria|tipo|valor|score|quantidade|tamanho\\n...\"\n// }\n\nconst THRESH_UNICO = Number($json.THRESH_UNICO ?? 0.80); // se quiser filtrar depois\nconst topn = Number($json.topn ?? 5);\nconst quantidadePadrao = Number($json.quantidade ?? 1);\nconst tamanhoPadrao = ($json.tamanho ?? null) || null;\n\nconst out = {\n  normalizado: $json.texto ?? '',\n  is_numero: !!$json.isNumero\n};\n\n// 1) coleta linhas vindas do Postgres\nlet rows = (items || []).map(i => i?.json).filter(Boolean);\n\n// aceita payload em string JSON (eventual)\nrows = rows.map(r => {\n  if (typeof r === 'string') {\n    try { return JSON.parse(r); } catch { return null; }\n  }\n  return r;\n}).filter(Boolean);\n\n// normaliza tipos\nrows = rows.map(r => ({\n  ...r,\n  numero: (r.numero != null ? Number(r.numero) : null),\n  score: Number(r.score ?? 0),\n  valor: (r.valor !== undefined && r.valor !== null) ? Number(r.valor) : null,\n  tipo: r.tipo ?? null,\n  categoria: r.categoria ?? null,\n  nome: r.nome ?? null,\n  tamanho_aplicado: r.tamanho_aplicado ?? null\n}));\n\n// 2) de-dup por numero (mantém melhor score)\nconst byNum = new Map();\nfor (const r of rows) {\n  if (r.numero == null) continue;\n  const k = String(r.numero);\n  const prev = byNum.get(k);\n  if (!prev || r.score > prev.score) byNum.set(k, r);\n}\nrows = Array.from(byNum.values());\n\n// 3) ordena e limita\nrows.sort((a, b) => (b.score - a.score) || (a.numero - b.numero));\nrows = rows.slice(0, topn);\n\n// 4) mapeia para estrutura FINAL uniforme\nconst itens = rows.map(r => ({\n  numero: r.numero,\n  nome: r.nome,\n  categoria: r.categoria,\n  tipo: r.tipo,\n  valor: r.valor,                             // já considerado pelo tamanho no SQL\n  score: r.score,\n  quantidade: Number($json.quantidade ?? quantidadePadrao),\n  tamanho: (tamanhoPadrao || r.tamanho_aplicado || null) // prioridade: input > aplicado\n}));\n\n// 5) string pronta pra split('\\n') ou salvar como texto\nconst linhas = itens.map(i =>\n  [\n    i.numero,\n    i.nome?.replace(/\\|/g, '/'), // protege o separador\n    i.categoria,\n    i.tipo,\n    (i.valor ?? '').toString().replace(/\\|/g, '/'),\n    i.score.toFixed(3),\n    i.quantidade,\n    i.tamanho ?? ''\n  ].join('|')\n).join('\\n');\n\n// 6) caso não haja nenhum item, retorna lista vazia e linhas=\"\"\nreturn [{\n  json: {\n    ...out,\n    total: itens.length,\n    itens,\n    linhas,\n    user_id:$('Edit Fields').first().json.user_id,\n    id_empresa:$('Edit Fields').first().json.empresa_id,\n    pedido_id:$('Edit Fields').first().json.pedido_id \n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1216,-32],"id":"0959f234-4989-4bd8-a6b9-3adc7d675c5f","name":"Code1"},{"parameters":{"operation":"executeQuery","query":" WITH params AS (\n  SELECT\n    {{ $('When Executed by Another Workflow').item.json.empresa_id }}::int AS empresa_id,\n    {{ $json.isNumero ? 'true' : 'false' }}::boolean                      AS is_numero,\n    {{ $json.isNumero ? $json.numero : 'NULL' }}::int                     AS numero,\n    '{{ ($json.texto || \"\").replace(/'/g, \"''\") }}'::text                 AS texto,\n    {{ $json.topn   || 5 }}::int                                          AS topn,\n    {{ $json.min_score || 0.35 }}::numeric                                AS min_score,\n    {{ $json.categoria ? `'${$json.categoria}'` : 'NULL' }}::text         AS categoria,\n    {{ $('Code4').item.json.tamanho ? `'${$('Code4').item.json.tamanho}'` : 'NULL' }}::text AS tamanho_raw\n),\nnorm AS (\n  SELECT CASE\n           WHEN tamanho_raw ~* 'gran'       THEN 'grande'\n           WHEN tamanho_raw ~* 'm(e|é)di'   THEN 'media'\n           WHEN tamanho_raw ~* 'peq|broto'  THEN 'pequena'\n           ELSE NULL\n         END AS tamanho_norm\n  FROM params\n),\n-- texto normalizado + flags\nq AS (\n  SELECT\n    unaccent(lower(texto)) AS qtxt,\n    position(' ' in unaccent(lower(texto))) = 0 AS is_single_word,\n    (unaccent(lower(texto)) ~ '(coca|guarana|antarctica|fanta|refrigerante|refri|agua|cerveja|vinho|suco)') AS quer_bebida\n  FROM params\n),\nhit_num AS (\n  SELECT\n    c.numero, c.nome, c.categoria, c.tipo,\n    c.preco_grande, c.preco_medio, c.preco_pequena,\n    CASE\n      WHEN (SELECT tamanho_norm FROM norm) = 'grande'  THEN c.preco_grande\n      WHEN (SELECT tamanho_norm FROM norm) = 'media'   THEN c.preco_medio\n      WHEN (SELECT tamanho_norm FROM norm) = 'pequena' THEN c.preco_pequena\n      ELSE COALESCE(c.preco_medio, c.preco_grande, c.preco_pequena)\n    END AS valor,\n    1.0::numeric AS score\n  FROM cardapio c, params p\n  WHERE c.id_empresa = p.empresa_id\n    AND p.is_numero\n    AND c.numero = p.numero\n    AND (p.categoria IS NULL OR lower(c.categoria) = lower(p.categoria))\n    AND ( (SELECT quer_bebida FROM q) OR lower(c.categoria) <> 'bebida' )\n  LIMIT 1\n),\n-- 1ª tentativa: texto de 1 palavra precisa aparecer como substring do nome\nrec_substr AS (\n  SELECT\n    c.numero, c.nome, c.categoria, c.tipo,\n    c.preco_grande, c.preco_medio, c.preco_pequena,\n    CASE\n      WHEN (SELECT tamanho_norm FROM norm) = 'grande'  THEN c.preco_grande\n      WHEN (SELECT tamanho_norm FROM norm) = 'media'   THEN c.preco_medio\n      WHEN (SELECT tamanho_norm FROM norm) = 'pequena' THEN c.preco_pequena\n      ELSE COALESCE(c.preco_medio, c.preco_grande, c.preco_pequena)\n    END AS valor,\n    GREATEST(similarity(unaccent(lower(c.nome)), (SELECT qtxt FROM q)), 0.90)::numeric AS score\n  FROM cardapio c, params p\n  WHERE NOT EXISTS (SELECT 1 FROM hit_num)\n    AND (SELECT is_single_word FROM q)\n    AND c.id_empresa = p.empresa_id\n    AND (p.categoria IS NULL OR lower(c.categoria) = lower(p.categoria))\n    AND ( (SELECT quer_bebida FROM q) OR lower(c.categoria) <> 'bebida' )\n    AND unaccent(lower(c.nome)) LIKE '%' || (SELECT qtxt FROM q) || '%'\n  ORDER BY score DESC, c.numero\n  LIMIT (SELECT topn FROM params)\n),\n-- 2ª tentativa: fallback fuzzy só se não houver substring match\nrec_fuzzy AS (\n  SELECT\n    c.numero, c.nome, c.categoria, c.tipo,\n    c.preco_grande, c.preco_medio, c.preco_pequena,\n    CASE\n      WHEN (SELECT tamanho_norm FROM norm) = 'grande'  THEN c.preco_grande\n      WHEN (SELECT tamanho_norm FROM norm) = 'media'   THEN c.preco_medio\n      WHEN (SELECT tamanho_norm FROM norm) = 'pequena' THEN c.preco_pequena\n      ELSE COALESCE(c.preco_medio, c.preco_grande, c.preco_pequena)\n    END AS valor,\n    r.score::numeric AS score\n  FROM params p\n  JOIN LATERAL resolve_cardapio(p.empresa_id, p.texto, p.topn, p.min_score) r ON TRUE\n  JOIN cardapio c\n    ON c.id_empresa = p.empresa_id AND c.numero = r.numero\n  WHERE NOT EXISTS (SELECT 1 FROM hit_num)\n    AND NOT EXISTS (SELECT 1 FROM rec_substr)\n    AND (p.categoria IS NULL OR lower(c.categoria) = lower(p.categoria))\n    AND ( (SELECT quer_bebida FROM q) OR lower(c.categoria) <> 'bebida' )\n)\nSELECT numero, nome, categoria, tipo,\n       preco_grande, preco_medio, preco_pequena,\n       valor, score\nFROM hit_num\nUNION ALL\nSELECT numero, nome, categoria, tipo,\n       preco_grande, preco_medio, preco_pequena,\n       valor, score\nFROM rec_substr\nUNION ALL\nSELECT numero, nome, categoria, tipo,\n       preco_grande, preco_medio, preco_pequena,\n       valor, score\nFROM rec_fuzzy\nORDER BY score DESC, numero\nLIMIT {{ $json.topn || 5 }};\n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[1040,-32],"id":"e3b7e0a3-1b39-4fd3-bfd4-d8d61d8858eb","name":"Execute a SQL query","credentials":{"postgres":{"id":"3NLaVyXonSrCcLE3","name":"Postgres account"}}},{"parameters":{"jsCode":" function norm(s){return (s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().trim();}\nconst texto = norm($json.texto || '');\nconst mNum = texto.match(/\\b\\d{1,3}\\b/);           // pega número simples\nconst isNumero = !!mNum;\nreturn [{ json: { empresa_id: $json.empresa_id, texto, isNumero, numero: isNumero ? Number(mNum[0]) : null,\n                  categoria: $json.categoria ?? null, topn: $json.topn ?? 5, min_score: $json.min_score ?? 0.35 } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[64,320],"id":"31a9b2b6-eea6-47f8-8304-084f145d0a04","name":"Code2"},{"parameters":{"fieldToSplitOut":"comandos","options":{}},"type":"n8n-nodes-base.splitOut","typeVersion":1,"position":[0,-48],"id":"f7cb97ac-046f-4821-b893-1d3fe13961e9","name":"Split Out"},{"parameters":{"jsCode":" function norm(s){\n  return (s||'').normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').toLowerCase().trim();\n}\nfunction mapTam(t){\n  const s = norm(t);\n  if (/gran/.test(s)) return 'grande';\n  if (/(m[eé]di|medi)/.test(s)) return 'media';\n  if (/(peq|broto)/.test(s)) return 'pequena';\n  return null;\n}\n\nconst raw = String( $('Edit Fields1').first().json.texto || $json.texto || '').trim();\nif (!raw) return [{ json: { comandos: [], pendentes: [], texto: '' } }];\n\nconst s = norm(raw);\n\n// corta antes de todo \"N\" (1..3 dígitos) seguido opcionalmente de categoria\nconst chunks = s.split(/(?=\\b\\d{1,3}\\b(?:\\s+(?:pizza|esfirra|borda|bebida)\\b)?)/g)\n  .map(t => t.trim()).filter(Boolean);\n\nlet prevCategoria = null;\nlet prevTamanho   = null;\n\nconst comandos  = [];\nconst pendentes = [];\n\nfor (const ch of chunks) {\n  let categoria = null;\n  if (/\\bpizza\\b/.test(ch)) categoria = 'pizza';\n  else if (/\\besfirra\\b/.test(ch)) categoria = 'esfirra';\n  else if (/\\bborda\\b/.test(ch)) categoria = 'borda';\n  else if (/(refrigerante|refri|coca|guarana|antarctica|fanta|agua|água|cerveja|suco|vinho)\\b/.test(ch)) categoria = 'bebida';\n  if (!categoria) categoria = prevCategoria;\n\n  let quantidade = 1;\n  const mQ = ch.match(/^\\s*(\\d{1,3})\\b/);\n  if (mQ) quantidade = Math.max(1, parseInt(mQ[1],10));\n\n  // volume (bebidas)\n  const volRe = /\\b(\\d+(?:[.,]\\d+)?)\\s*(l|ml)\\b/;\n  let volume=null; const mVol=ch.match(volRe);\n  if (mVol) { const num=mVol[1].replace(',', '.'); volume = mVol[2]==='l' ? `${num.replace(/\\.0$/,'')}l` : `${parseInt(num,10)}ml`; }\n\n  // tamanho (pizza)\n  let tamanho=null; const mT=ch.match(/\\b(grande|m[eé]dia|media|pequena|broto)\\b/);\n  if (mT) tamanho = mapTam(mT[0]); else if (categoria==='pizza') tamanho = prevTamanho;\n\n  // proteger volume antes de caçar números soltos\n  const chNoVol = ch.replace(volRe, ' VOL ');\n\n  // número do cardápio (ignora a quantidade do início)\n  let numero=null;\n  const nums=(chNoVol.match(/\\b\\d{1,3}\\b/g)||[]).map(n=>parseInt(n,10));\n  if (nums.length){\n    if (mQ && parseInt(mQ[1],10)===nums[0]) numero = nums[1] ?? null; else numero = nums[0];\n  }\n\n  // nome “restante”\n  let nome = ch\n    .replace(/^\\s*\\d+\\s*/,'')\n    .replace(/\\b(pizza|esfirra|bebida|refrigerante|refri|borda)\\b/g,' ')\n    .replace(/\\b(grande|m[eé]dia|media|pequena|broto)\\b/g,' ')\n    .replace(/\\b(com|sem|de|da|do|e)\\b/g,' ')\n    .replace(volRe,' ')\n    .replace(/\\b\\d{1,3}\\b/g,' ')\n    .replace(/\\s+/g,' ')\n    .trim() || null;\n\n  // montar saída simples\n  if (categoria === 'pizza') {\n    if (!tamanho) { pendentes.push({ linha: ch, motivo:'pizza_sem_tamanho' }); prevCategoria=categoria; continue; }\n    if (numero != null) comandos.push(`${quantidade} pizza ${numero} ${tamanho}`);\n    else if (nome)      comandos.push(`${quantidade} pizza ${nome} ${tamanho}`);\n    else                pendentes.push({ linha: ch, motivo:'pizza_sem_nome_ou_numero' });\n    prevCategoria = 'pizza'; prevTamanho = tamanho;\n    continue;\n  }\n  if (categoria === 'esfirra') {\n    if (numero != null) comandos.push(`${quantidade} esfirra ${numero}`);\n    else if (nome)      comandos.push(`${quantidade} esfirra ${nome}`);\n    else                pendentes.push({ linha: ch, motivo:'esfirra_sem_nome_ou_numero' });\n    prevCategoria = 'esfirra'; continue;\n  }\n  if (categoria === 'bebida') {\n    if (numero != null) comandos.push(`${quantidade} ${numero}`);\n    else if (nome)      comandos.push(`${quantidade} ${nome}${volume ? ' ' + volume : ''}`);\n    else if (volume)    comandos.push(`${quantidade} ${volume}`);\n    else                pendentes.push({ linha: ch, motivo:'bebida_sem_nome_ou_numero' });\n    prevCategoria = 'bebida'; continue;\n  }\n\n  // sem categoria: se tiver número, deixe \"Q NUMERO\"\n  if (numero != null) comandos.push(`${quantidade} ${numero}`);\n  else pendentes.push({ linha: ch, motivo:'indefinido' });\n}\n\nreturn [{ json: { comandos, pendentes, texto: comandos.join('\\n') } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-240,-48],"id":"ce85b0a8-3503-49e3-b1c8-e9bcde1753c2","name":"Code3"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[288,-48],"id":"3aa8c040-beec-456c-b8b0-69c1829646df","name":"Loop Over Items"},{"parameters":{},"type":"n8n-nodes-base.noOp","name":"Replace Me","typeVersion":1,"position":[464,-256],"id":"0e54bbaa-e4ff-49a7-b700-0c9ce0804ccc"},{"parameters":{"jsCode":" // INPUT: $json.message (ex.: \"1 pizza mussarela , grande\")\n// OUTPUT: { quantidade, nome, tamanho, categoria, numero }\n\nfunction norm(s){\n  return (s||'')\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g,'') // tira acentos\n    .toLowerCase().trim();\n}\nfunction mapTam(t){\n  const x = norm(t);\n  if (/gran/.test(x)) return 'grande';\n  if (/(m[eé]di|medi)/.test(x)) return 'media';\n  if (/(peq|broto)/.test(x)) return 'pequena';\n  return null;\n}\n\nconst raw = String(  $('Loop Over Items').first().json.comandos || $json.text || '').trim();\nlet s = norm(raw).replace(/[,]+/g, ' '); // vírgulas viram espaço\n\n// categoria\nlet categoria = null;\nif (/\\bpizza\\b/.test(s)) categoria = 'pizza';\nelse if (/\\besfirra\\b/.test(s)) categoria = 'esfirra';\nelse if (/\\bborda\\b/.test(s)) categoria = 'borda';\nelse if (/(refrigerante|refri|coca|guarana|antarctica|fanta|agua|água|cerveja|suco|vinho)\\b/.test(s)) categoria = 'bebida';\nelse if (/\\bitem\\b/.test(s)) categoria = 'item';\n\n// quantidade (primeiro número no começo)\nlet quantidade = 1;\nconst mQ = s.match(/^\\s*(\\d{1,3})\\b/);\nif (mQ) quantidade = Math.max(1, parseInt(mQ[1],10));\n\n// tamanho\nlet tamanho = null;\nconst mT = s.match(/\\b(grande|m[eé]dia|media|pequena|broto)\\b/i);\nif (mT) tamanho = mapTam(mT[0]);\n\n// proteger volume (2l, 350ml) para não confundir com número do cardápio\nconst volRe = /\\b(\\d+(?:[.,]\\d+)?)\\s*(l|ml)\\b/gi;\nconst sNoVol = s.replace(volRe, ' VOL ');\n\n// número do cardápio (ignora a quantidade do início e volumes)\nlet numero = null;\nconst nums = (sNoVol.match(/\\b\\d{1,3}\\b/g) || []).map(n => parseInt(n,10));\nif (nums.length){\n  if (mQ && parseInt(mQ[1],10) === nums[0]) numero = nums[1] ?? null;\n  else numero = nums[0];\n}\n\n// nome limpo\nlet nome = s\n  .replace(/^\\s*\\d+\\s*/,'')                                   // tira quantidade\n  .replace(/\\b(pizza|esfirra|bebida|refrigerante|refri|borda|item)\\b/g,' ')\n  .replace(/\\b(grande|m[eé]dia|media|pequena|broto)\\b/g,' ')\n  .replace(/\\b(com|sem|de|da|do|e)\\b/g,' ')\n  .replace(volRe,' ')                                          // remove volumes\n  .replace(/\\b\\d{1,3}\\b/g,' ')                                 // remove números restantes\n  .replace(/\\s+/g,' ')\n  .trim() || null;\n\n// fallback: quando não há categoria explícita e existe um número, trate como \"item\"\nif (!categoria && numero != null) categoria = 'item';\n\nreturn [{ json: { quantidade, nome, tamanho, categoria, numero } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[672,-32],"id":"18a77adc-b3fb-45cf-a2ab-1fb27e30205a","name":"Code4"},{"parameters":{"tableId":"intencao_opcao","fieldsUi":{"fieldValues":[{"fieldId":"user_id","fieldValue":"= {{ $('Code1').item.json.user_id }}"},{"fieldId":"pedido_id","fieldValue":"={{ $('Code1').item.json.pedido_id }}"},{"fieldId":"numero","fieldValue":"={{ $json.numero }}"},{"fieldId":"categoria","fieldValue":"={{ $json.categoria }}"},{"fieldId":"id_empresa","fieldValue":"={{ $('Code1').item.json.id_empresa }}"},{"fieldId":"nome","fieldValue":"={{ $json.nome }}"},{"fieldId":"opcao","fieldValue":"={{$itemIndex + 1}}"},{"fieldId":"tipo","fieldValue":"={{ $json.tipo }}"},{"fieldId":"valor","fieldValue":"={{ $json.valor }}"}]}},"type":"n8n-nodes-base.supabase","typeVersion":1,"position":[1616,-32],"id":"cdb5c7d8-de23-4c1b-aae7-4ea36f623746","name":"Create a row","credentials":{"supabaseApi":{"id":"CcvRddDPb5xelxfb","name":"Supabase account"}}},{"parameters":{"jsCode":" const rows = items.map(i=>i.json);\nconst out = { normalizado: $json.texto, is_numero: $json.isNumero };\n\nif (!rows.length) {\n  return [{ json: { ...out, status: 'nao_encontrado' } }];\n}\nif (rows.length === 1 || (rows[0].score ?? 0) >= 0.8) {\n  const r = rows[0];\n  return [{ json: { ...out, status: 'unico', candidato: {\n    numero: r.numero, nome: r.nome, score: r.score ?? 1.0, categoria: r.categoria\n  } } }];\n}\nreturn [{ json: { ...out, status: 'opcoes', opcoes: rows.map((r,i)=>({\n  i: i+1, numero: r.numero, nome: r.nome, score: r.score ?? 0\n})) } }];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1120,272],"id":"221a3f77-c5ad-4935-b13e-b667b88688bd","name":"Code5"},{"parameters":{"jsCode":" // INPUT esperado por item: { quantidade, nome, tamanho, categoria, numero, empresa_id? }\n// OUTPUT por item: { empresa_id, quantidade, categoria, tamanho, isNumero, numero, texto, topn, min_score }\n\nfunction norm(s){\n  return (s||'').toString()\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g,'') // sem acentos\n    .toLowerCase().trim();\n}\nfunction mapTam(t){\n  const x = norm(t||'');\n  if (/gran/.test(x)) return 'grande';\n  if (/(m[eé]di|medi)/.test(x)) return 'media';\n  if (/(peq|broto)/.test(x)) return 'pequena';\n  return null;\n}\n\n// Se precisar pegar empresa_id de outro node, descomente a linha abaixo\n// const empresaIdGlobal = $('When Executed by Another Workflow').item.json.empresa_id;\n\nreturn items.map(it => {\n  const j = it.json;\n\n  const empresa_id = j.empresa_id /*?? empresaIdGlobal*/ ?? $json.empresa_id;\n  const quantidade = Number(j.quantidade ?? 1);\n  const categoria  = j.categoria ?? null;\n  const tamanho    = mapTam(j.tamanho);               // normaliza: grande|media|pequena|null\n  const hasNumero  = j.numero !== undefined && j.numero !== null && j.numero !== '';\n  const numero     = hasNumero ? Number(j.numero) : null;\n\n  // texto para resolver por nome quando não há número\n  const texto = hasNumero ? '' : norm(j.nome || $json.texto || $json.message || '');\n\n  return {\n    json: {\n      empresa_id,\n      quantidade,\n      categoria,\n      tamanho,             // <- vai pro SQL escolher o preço\n      isNumero: hasNumero,\n      numero,\n      texto,               // nome normalizado quando não houver número\n      topn: Number($json.topn ?? 5),\n      min_score: Number($json.min_score ?? 0.35)\n    }\n  };\n});\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[464,448],"id":"5f0c91ed-49be-4176-a7c2-65a5ca5e7b4e","name":"Code6"},{"parameters":{"operation":"executeQuery","query":" WITH params AS (\n  SELECT\n    {{ $('When Executed by Another Workflow').item.json.empresa_id }}::int AS empresa_id,\n    {{ $json.isNumero ? 'true' : 'false' }}::boolean                      AS is_numero,\n    {{ $json.isNumero ? $json.numero : 'NULL' }}::int                     AS numero,\n    '{{ ($json.texto || \"\").replace(/'/g, \"''\") }}'::text                 AS texto,\n    {{ $json.topn   || 5 }}::int                                          AS topn,\n    {{ $json.min_score || 0.35 }}::numeric                                AS min_score,\n    {{ $json.categoria ? `'${$json.categoria}'` : 'NULL' }}::text         AS categoria,\n    {{ $json.tamanho  ? `'${$json.tamanho}'`  : 'NULL' }}::text           AS tamanho_raw\n),\nnorm AS (\n  SELECT CASE\n           WHEN tamanho_raw ~* 'gran'       THEN 'grande'\n           WHEN tamanho_raw ~* 'm(e|é)di'   THEN 'media'\n           WHEN tamanho_raw ~* 'peq|broto'  THEN 'pequena'\n           ELSE NULL\n         END AS tamanho_norm\n  FROM params\n),\nhit_num AS (\n  SELECT\n    c.numero, c.nome, c.categoria, c.tipo,\n    c.preco_grande, c.preco_medio, c.preco_pequena,\n    CASE\n      WHEN (SELECT tamanho_norm FROM norm) = 'grande'  THEN c.preco_grande\n      WHEN (SELECT tamanho_norm FROM norm) = 'media'   THEN c.preco_medio\n      WHEN (SELECT tamanho_norm FROM norm) = 'pequena' THEN c.preco_pequena\n      ELSE COALESCE(c.preco_medio, c.preco_grande, c.preco_pequena)\n    END AS valor,\n    1.0::numeric AS score\n  FROM cardapio c, params p\n  WHERE c.id_empresa = p.empresa_id\n    AND p.is_numero\n    AND c.numero = p.numero\n    AND (p.categoria IS NULL OR lower(c.categoria) = lower(p.categoria))\n  LIMIT 1\n),\nrec AS (\n  SELECT\n    c.numero, c.nome, c.categoria, c.tipo,\n    c.preco_grande, c.preco_medio, c.preco_pequena,\n    CASE\n      WHEN (SELECT tamanho_norm FROM norm) = 'grande'  THEN c.preco_grande\n      WHEN (SELECT tamanho_norm FROM norm) = 'media'   THEN c.preco_medio\n      WHEN (SELECT tamanho_norm FROM norm) = 'pequena' THEN c.preco_pequena\n      ELSE COALESCE(c.preco_medio, c.preco_grande, c.preco_pequena)\n    END AS valor,\n    r.score::numeric AS score\n  FROM params p\n  JOIN LATERAL resolve_cardapio(p.empresa_id, p.texto, p.topn, p.min_score) r ON TRUE\n  JOIN cardapio c\n    ON c.id_empresa = p.empresa_id AND c.numero = r.numero\n  WHERE NOT EXISTS (SELECT 1 FROM hit_num)\n    AND (p.categoria IS NULL OR lower(c.categoria) = lower(p.categoria))\n)\nSELECT numero, nome, categoria, tipo,\n       preco_grande, preco_medio, preco_pequena,\n       valor, score\nFROM hit_num\nUNION ALL\nSELECT numero, nome, categoria, tipo,\n       preco_grande, preco_medio, preco_pequena,\n       valor, score\nFROM rec\nORDER BY score DESC, numero\nLIMIT {{ $json.topn || 5 }};\n{{ $('Code4').item.json.tamanho }}\n\n  \n","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[928,256],"id":"685db594-aac1-41f8-a329-9cef6ef306b5","name":"Execute a SQL query1","credentials":{"postgres":{"id":"3NLaVyXonSrCcLE3","name":"Postgres account"}}},{"parameters":{"assignments":{"assignments":[{"id":"3f194e58-de3d-48a4-893b-7415b22775cb","name":"user_id","value":"={{ $('When Executed by Another Workflow').item.json.user_id }}","type":"number"},{"id":"e0b2e0f7-5fd3-4ae9-8796-691442492c8f","name":"pedido_id","value":"={{ $('When Executed by Another Workflow').item.json.pedido_id }}","type":"number"},{"id":"7f9663e8-9b8d-452e-921e-46ef77271479","name":"empresa_id","value":"={{ $('When Executed by Another Workflow').item.json.empresa_id }}","type":"number"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[496,-32],"id":"bc40ae17-b2b9-41e2-84ab-7196974e0447","name":"Edit Fields","executeOnce":true},{"parameters":{"jsCode":" // knobs\nconst THRESH_UNICO = Number($json.THRESH_UNICO ?? 0.80);\nconst AMBIG_DELTA  = Number($json.AMBIG_DELTA  ?? 0.10);\n\nconst out = { normalizado: $json.texto, is_numero: !!$json.isNumero };\n\n// 1) coleta e saneia linhas do Postgres\nlet rows = (items || []).map(i => i?.json).filter(Boolean);\n\n// aceita payload em string JSON (eventual)\nrows = rows.map(r => {\n  if (typeof r === 'string') {\n    try { return JSON.parse(r); } catch { return null; }\n  }\n  return r;\n}).filter(Boolean);\n\n// força tipos numéricos\nrows = rows.map(r => ({\n  ...r,\n  score: Number(r.score ?? 0),\n  valor: (r.valor !== undefined && r.valor !== null) ? Number(r.valor) : null\n}));\n\n// 2) de-dup por numero (mantém o maior score)\nconst byNum = new Map();\nfor (const r of rows) {\n  if (r.numero == null) continue;\n  const k = String(r.numero);\n  const prev = byNum.get(k);\n  if (!prev || r.score > prev.score) byNum.set(k, r);\n}\nrows = Array.from(byNum.values());\n\n// ordena: score desc, numero asc\nrows.sort((a, b) => (b.score - a.score) || (Number(a.numero) - Number(b.numero)));\n\n// 3) se veio número explícito e ele está nos resultados, é único\nif ($json.isNumero && $json.numero != null) {\n  const alvo = rows.find(r => Number(r.numero) === Number($json.numero));\n  if (alvo) {\n    return [{\n      json: {\n        ...out,\n        status: 'unico',\n        candidato: {\n          numero: alvo.numero,\n          nome: alvo.nome,\n          categoria: alvo.categoria ?? null,\n          tipo: alvo.tipo ?? null,\n          valor: alvo.valor,          // << AQUI\n          score: alvo.score\n        }\n      }\n    }];\n  }\n}\n\n// 4) sem candidatos\nif (!rows.length) {\n  return [{ json: { ...out, status: 'nao_encontrado' } }];\n}\n\n// 5) decide único x opções (com ambiguidade)\nconst top1 = rows[0];\nconst top2 = rows[1];\nconst closeToTop = top2 ? (top1.score - top2.score) < AMBIG_DELTA : false;\n\nif (rows.length === 1 || top1.score >= THRESH_UNICO) {\n  if (closeToTop && top1.score < 0.95) {\n    return [{\n      json: {\n        ...out,\n        status: 'opcoes',\n        opcoes: rows.slice(0, $json.topn ?? 5).map((r, i) => ({\n          i: i + 1,\n          numero: r.numero,\n          nome: r.nome,\n          categoria: r.categoria ?? null,\n          tipo: r.tipo ?? null,       // << AQUI\n          valor: r.valor,             // << AQUI\n          score: r.score\n        }))\n      }\n    }];\n  }\n  return [{\n    json: {\n      ...out,\n      status: 'unico',\n      candidato: {\n        numero: top1.numero,\n        nome: top1.nome,\n        categoria: top1.categoria ?? null,\n        tipo: top1.tipo ?? null,      // << AQUI\n        valor: top1.valor,            // << AQUI\n        score: top1.score\n      }\n    }\n  }];\n}\n\n// 6) várias opções\nreturn [{\n  json: {\n    ...out,\n    status: 'opcoes',\n    opcoes: rows.slice(0, $json.topn ?? 5).map((r, i) => ({\n      i: i + 1,\n      numero: r.numero,\n      nome: r.nome,\n      categoria: r.categoria ?? null,\n      tipo: r.tipo ?? null,           // << AQUI\n      valor: r.valor,                 // << AQUI\n      score: r.score\n    }))\n  }\n}];\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[1856,-128],"id":"593c7b1b-3452-479d-afcf-9dc957b9cfd4","name":"Code7"},{"parameters":{"operation":"executeQuery","query":"delete from intencao_opcao where user_id = {{ $('When Executed by Another Workflow').item.json.user_id }} and pedido_id = {{ $('When Executed by Another Workflow').item.json.pedido_id }} and id_empresa = {{ $('When Executed by Another Workflow').item.json.empresa_id }};","options":{}},"type":"n8n-nodes-base.postgres","typeVersion":2.6,"position":[-480,-48],"id":"52213446-a580-4f81-a47d-5d8990ea5387","name":"Execute a SQL query2","alwaysOutputData":true,"credentials":{"postgres":{"id":"3NLaVyXonSrCcLE3","name":"Postgres account"}}},{"parameters":{"fieldToSplitOut":"itens","options":{}},"type":"n8n-nodes-base.splitOut","typeVersion":1,"position":[1408,-32],"id":"8ae4eb3f-0cd0-4e51-aa06-df2b4d892251","name":"Split variasopc"},{"parameters":{"assignments":{"assignments":[{"id":"3a376baf-b53d-4709-a2a6-2b5e16619bcb","name":"empresa_id","value":"={{ $json.empresa_id }}","type":"string"},{"id":"33a98f88-1cbc-481e-89f3-abed44aed9be","name":"texto","value":"={{ $json.texto }}","type":"string"},{"id":"495b2ad7-123a-408f-9b8f-66c5d03d62ce","name":"categoria","value":"={{ $json.categoria }}","type":"string"},{"id":"dff344ba-44e5-4b47-a40a-722b2363c2b0","name":"topn","value":"={{ $json.topn }}","type":"string"},{"id":"851748da-0e92-4e6d-84d6-f2b6abee0457","name":"user_id","value":"={{ $json.user_id }}","type":"string"},{"id":"b8c5a3c5-7b90-491a-ac4a-bf6968b4031f","name":"pedido_id","value":"={{ $json.pedido_id }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[-656,-48],"id":"e5ecd8ee-6fae-49d6-99f8-f18e89dee395","name":"Edit Fields1"}],"connections":{"When Executed by Another Workflow":{"main":[[{"node":"Edit Fields1","type":"main","index":0}]]},"Code":{"main":[[{"node":"Execute a SQL query","type":"main","index":0}]]},"Execute a SQL query":{"main":[[{"node":"Code1","type":"main","index":0}]]},"Code1":{"main":[[{"node":"Split variasopc","type":"main","index":0}]]},"Code3":{"main":[[{"node":"Split Out","type":"main","index":0}]]},"Loop Over Items":{"main":[[{"node":"Replace Me","type":"main","index":0}],[{"node":"Edit Fields","type":"main","index":0}]]},"Replace Me":{"main":[[]]},"Split Out":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Code4":{"main":[[{"node":"Code","type":"main","index":0}]]},"Create a row":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Edit Fields":{"main":[[{"node":"Code4","type":"main","index":0}]]},"Execute a SQL query2":{"main":[[{"node":"Code3","type":"main","index":0}]]},"Split variasopc":{"main":[[{"node":"Create a row","type":"main","index":0}]]},"Edit Fields1":{"main":[[{"node":"Execute a SQL query2","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{"When Executed by Another Workflow":[{"json":{"empresa_id":1,"texto":"1 pizza baiana grande","categoria":null,"topn":5,"min_score":0.35,"user_id":72,"pedido_id":38}}]},"versionId":"7c00594e-3ceb-4afa-bbe3-7f34f50b9b15","triggerCount":0,"shared":[{"createdAt":"2025-10-03T16:04:00.258Z","updatedAt":"2025-10-03T16:04:00.258Z","role":"workflow:owner","workflowId":"p0pZuoGt8Vj7rxwI","projectId":"wFRMrac2003Pl1x6"}],"tags":[]}