 CREATE OR REPLACE FUNCTION public.kpi_termometro_dia(
  p_id_empresa  INT,
  p_data        DATE DEFAULT (now() AT TIME ZONE 'America/Sao_Paulo')::date,
  p_taxa_entrega NUMERIC DEFAULT 3.00
)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $$
 
DECLARE
  result JSONB;
BEGIN
  WITH base_p AS (
    SELECT
      p.pedido_id                                    AS id,
      (p.create_at AT TIME ZONE 'America/Sao_Paulo') AS ts,
      CASE
        WHEN lower(coalesce(p.tipo_entrega,'retirada')) IN ('casa','entrega','delivery') THEN 'entrega'
        ELSE 'retirada'
      END                                            AS tipo,
      COALESCE(p.valor,0)::numeric                   AS valor_pedido
    FROM pedidos p
    WHERE p.id_empresa = p_id_empresa
      AND (p.create_at AT TIME ZONE 'America/Sao_Paulo')::date = p_data
  ),
  -- total do item (valor; se nulo, tenta valor_unitario*quantidade + valor_fracao)
  itens AS (
    SELECT
      i.pedido_id,
      i.numero,
      COALESCE(
        i.valor::numeric,
        (COALESCE(i.valor_unitario,0)::numeric * GREATEST(COALESCE(i.quantidade,1),1))
          + COALESCE(i.valor_fracao,0)::numeric,
        0::numeric
      ) AS item_total
    FROM item_pedido i
    JOIN base_p p ON p.id = i.pedido_id
    WHERE i.id_empresa = p_id_empresa
  ),
  totais AS (
    SELECT
      p.id,
      COALESCE(SUM(i.item_total), p.valor_pedido) AS total,
      p.tipo,
      date_part('hour', p.ts)::int               AS hora
    FROM base_p p
    LEFT JOIN itens i ON i.pedido_id = p.id
    GROUP BY p.id, p.tipo, p.ts, p.valor_pedido
  ),
  kpi AS (
    SELECT
      COUNT(*)::int                                         AS pedidos,
      COALESCE(SUM(total),0)::numeric                       AS receita_bruta,
      SUM(CASE WHEN tipo='entrega' THEN 1 ELSE 0 END)::int  AS entrega_qtd,
      SUM(CASE WHEN tipo='retirada' THEN 1 ELSE 0 END)::int AS retirada_qtd,
      COALESCE(MAX(total),0)::numeric                       AS pedido_max,
      COALESCE(MIN(total),0)::numeric                       AS pedido_min
    FROM totais
  ),
  hora_agg AS (
    SELECT hora, COUNT(*)::int AS pedidos, COALESCE(SUM(total),0)::numeric AS total
    FROM totais
    GROUP BY hora
    ORDER BY hora
  ),
  -- estatística por item do dia (pega do item_pedido)
  item_stats AS (
    SELECT
      COALESCE(MAX(item_total),0)::numeric AS item_max,
      COALESCE(MIN(item_total),0)::numeric AS item_min
    FROM itens
  ),
  -- top 5 itens do dia
  top_itens AS (
    SELECT
      COALESCE(c.nome, 'Item '||i.numero::text) AS nome,
      COUNT(*)::int                              AS qtd,
      COALESCE(SUM(i.item_total),0)::numeric    AS total
    FROM itens i
    LEFT JOIN cardapio c
      ON c.numero = i.numero
     AND c.id_empresa = p_id_empresa
    GROUP BY 1
    ORDER BY total DESC
    LIMIT 5
  ),
  -- itens sem modelo de custo
  faltando_modelo AS (
    SELECT COUNT(*)::int AS qtd
    FROM itens i
    LEFT JOIN cardapio c
      ON c.numero = i.numero
     AND c.id_empresa = p_id_empresa
    WHERE COALESCE(c.id_referencia,0) = 0
       OR c.id_referencia IS NULL
  ),
  -- margem estimada usando (margem_min + margem_max)/2
  margem AS (
    SELECT
      COALESCE(SUM(i.item_total),0)::numeric AS receita_itens,
      COALESCE(SUM(
        i.item_total * (1 - ((m.margem_min + m.margem_max)/2.0))
      ),0)::numeric AS custo_estimado,
      COALESCE(SUM(i.item_total),0)::numeric
      - COALESCE(SUM(
          i.item_total * (1 - ((m.margem_min + m.margem_max)/2.0))
        ),0)::numeric AS margem_estimada
    FROM itens i
    JOIN cardapio c
      ON c.numero = i.numero
     AND c.id_empresa = p_id_empresa
    JOIN pizza_modelo m
      ON m.id_referencia = c.id_referencia
    -- se quiser filtrar por modelo da mesma empresa (se existir essa relação), adicione:
    -- AND (m.id_empresa IS NULL OR m.id_empresa = p_id_empresa)
  )
  SELECT jsonb_build_object(
    'pedidos',                k.pedidos,
    'receita_bruta',          round(k.receita_bruta, 2),
    'entrega_qtd',            k.entrega_qtd,
    'retirada_qtd',           k.retirada_qtd,
    'entrega_taxa_unit',      round(p_taxa_entrega, 2),
    'entrega_taxa_total',     round((k.entrega_qtd * p_taxa_entrega)::numeric, 2), -- ex.: 60,00
    'receita_liquida',        round((k.receita_bruta - (k.entrega_qtd * p_taxa_entrega))::numeric, 2),
    'ticket_medio_liquido',   round(CASE WHEN k.pedidos>0
                                         THEN (k.receita_bruta - (k.entrega_qtd * p_taxa_entrega))/k.pedidos
                                         ELSE 0 END, 2),
    'pedido_max',             round(k.pedido_max, 2),
    'pedido_min',             round(k.pedido_min, 2),
    'item_max',               round(s.item_max, 2),
    'item_min',               round(s.item_min, 2),
    'vendas_hora', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'hora', hora, 'pedidos', pedidos, 'total', round(total,2)
      ) ORDER BY hora)
      FROM hora_agg
    ), '[]'::jsonb),
    'top_itens', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'nome', nome, 'qtd', qtd, 'total', round(total,2)
      ) ORDER BY total DESC)
      FROM top_itens
    ), '[]'::jsonb),
    'itens_sem_modelo', (SELECT qtd FROM faltando_modelo),
    'margem_estimada', (
      SELECT jsonb_build_object(
        'receita_itens',   round(receita_itens,2),
        'custo_estimado',  round(custo_estimado,2),
        'margem_estimada', round(margem_estimada,2)
      ) FROM margem
    ),
    'observacoes', jsonb_build_object(
      'regra', 'receita_liquida = receita_bruta - (taxa_entrega * qtd_entrega)',
      'fonte_total_pedido', 'soma de itens; se vazio, usa pedidos.valor',
      'mapa_tipo_entrega', 'casa/entrega/delivery => entrega; outros => retirada'
    )
  ) INTO result
  FROM kpi k CROSS JOIN item_stats s;

  RETURN result;
END;

$$;
