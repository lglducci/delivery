CREATE OR REPLACE FUNCTION export_extras(p_schema text DEFAULT 'public')
RETURNS SETOF text
LANGUAGE plpgsql AS $$
DECLARE
  r RECORD;
BEGIN
  -------------------------------------------------------------------
  -- SEQUENCES
  -------------------------------------------------------------------
  FOR r IN
    SELECT n.nspname       AS schema_name,
           c.relname       AS seq_name,
           s.seqstart      AS start_value,
           s.seqincrement  AS increment_by,
           s.seqmin        AS min_value,
           s.seqmax        AS max_value,
           s.seqcache      AS cache_value,
           s.seqcycle      AS is_cycled
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    JOIN pg_sequence s  ON s.seqrelid = c.oid
    WHERE c.relkind = 'S'
      AND n.nspname = p_schema
  LOOP
    RETURN NEXT FORMAT('DROP SEQUENCE IF EXISTS %I.%I CASCADE;', r.schema_name, r.seq_name);
    RETURN NEXT FORMAT(
      'CREATE SEQUENCE %I.%I START %s INCREMENT %s MINVALUE %s MAXVALUE %s CACHE %s %s;',
      r.schema_name, r.seq_name,
      r.start_value, r.increment_by, r.min_value, r.max_value, r.cache_value,
      CASE WHEN r.is_cycled THEN 'CYCLE' ELSE 'NO CYCLE' END
    );
  END LOOP;

  -------------------------------------------------------------------
  -- FUNCTIONS & PROCEDURES
  -------------------------------------------------------------------
  FOR r IN
    SELECT p.oid, n.nspname, p.proname
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = p_schema
      AND p.prokind IN ('f','p') -- f=function, p=procedure
      AND n.nspname NOT IN ('pg_catalog','information_schema')
  LOOP
    RETURN NEXT FORMAT('DROP FUNCTION IF EXISTS %I.%I CASCADE;', r.nspname, r.proname);
    RETURN NEXT pg_get_functiondef(r.oid);
  END LOOP;

  -------------------------------------------------------------------
  -- TRIGGERS
  -------------------------------------------------------------------
  FOR r IN
    SELECT tg.oid, tg.tgname, c.relname AS tab, n.nspname
    FROM pg_trigger tg
    JOIN pg_class c ON c.oid = tg.tgrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE NOT tg.tgisinternal
      AND n.nspname = p_schema
  LOOP
    RETURN NEXT FORMAT('DROP TRIGGER IF EXISTS %I ON %I.%I;', r.tgname, r.nspname, r.tab);
    RETURN NEXT pg_get_triggerdef(r.oid) || ';';
  END LOOP;

  -------------------------------------------------------------------
  -- TYPES (ENUMS)
  -------------------------------------------------------------------
  FOR r IN
    SELECT n.nspname, t.typname,
           STRING_AGG(QUOTE_LITERAL(e.enumlabel), ', ' ORDER BY e.enumsortorder) AS labels
    FROM pg_type t
    JOIN pg_namespace n ON n.oid=t.typnamespace
    JOIN pg_enum e ON e.enumtypid=t.oid
    WHERE n.nspname = p_schema
    GROUP BY n.nspname, t.typname
  LOOP
    RETURN NEXT FORMAT('DROP TYPE IF EXISTS %I.%I CASCADE;', r.nspname, r.typname);
    RETURN NEXT FORMAT('CREATE TYPE %I.%I AS ENUM (%s);', r.nspname, r.typname, r.labels);
  END LOOP;

  -------------------------------------------------------------------
  -- COMMENTS
  -------------------------------------------------------------------
  FOR r IN
    SELECT obj_description(c.oid) AS comment, n.nspname, c.relname
    FROM pg_class c
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = p_schema
      AND obj_description(c.oid) IS NOT NULL
  LOOP
    RETURN NEXT FORMAT('COMMENT ON TABLE %I.%I IS %L;', r.nspname, r.relname, r.comment);
  END LOOP;

  RETURN;
END;
$$;
