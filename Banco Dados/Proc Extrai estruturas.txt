 CREATE OR REPLACE FUNCTION export_schema(p_schema text DEFAULT 'public')
RETURNS SETOF text
LANGUAGE plpgsql AS $$
DECLARE
  r RECORD;
  cols TEXT;
  cons TEXT;
BEGIN
  -- ENUM TYPES
  FOR r IN
    SELECT n.nspname AS sch, t.typname,
           STRING_AGG(QUOTE_LITERAL(e.enumlabel), ', ' ORDER BY e.enumsortorder) AS labels
    FROM pg_type t
    JOIN pg_namespace n ON n.oid=t.typnamespace
    JOIN pg_enum e ON e.enumtypid=t.oid
    WHERE n.nspname = p_schema
    GROUP BY 1,2
  LOOP
    RETURN NEXT FORMAT('DROP TYPE IF EXISTS %I.%I CASCADE;', r.sch, r.typname);
    RETURN NEXT FORMAT('CREATE TYPE %I.%I AS ENUM (%s);', r.sch, r.typname, r.labels);
  END LOOP;

  -- TABLES (base/particionadas)
  FOR r IN
    SELECT c.oid AS relid, n.nspname AS sch, c.relname AS tab
    FROM pg_class c
    JOIN pg_namespace n ON n.oid=c.relnamespace
    WHERE n.nspname=p_schema AND c.relkind IN ('r','p')
    ORDER BY c.relname
  LOOP
    cols := NULL;

    -- COLUNAS
    SELECT STRING_AGG(
             FORMAT('  %I %s%s%s%s',
               a.attname,
               pg_catalog.format_type(a.atttypid,a.atttypmod),
               CASE WHEN a.attidentity <> '' THEN
                    ' GENERATED ' || CASE a.attidentity WHEN 'a' THEN 'ALWAYS' ELSE 'BY DEFAULT' END || ' AS IDENTITY'
               ELSE '' END,
               CASE WHEN ad.adbin IS NOT NULL THEN ' DEFAULT '||pg_get_expr(ad.adbin, r.relid) ELSE '' END,
               CASE WHEN a.attnotnull THEN ' NOT NULL' ELSE '' END
             ),
             E',\n' ORDER BY a.attnum
           )
      INTO cols
    FROM pg_attribute a
    LEFT JOIN pg_attrdef ad ON ad.adrelid=a.attrelid AND ad.adnum=a.attnum
    WHERE a.attrelid=r.relid AND a.attnum>0 AND NOT a.attisdropped;

    -- CONSTRAINTS inline (PK/UNIQUE/CHECK)
    SELECT COALESCE(STRING_AGG(
             FORMAT(',%s  CONSTRAINT %I %s', E'\n', conname, pg_get_constraintdef(oid,true)),
             '' ORDER BY CASE WHEN contype='p' THEN 0 WHEN contype='u' THEN 1 ELSE 2 END, conname
           ), '')
      INTO cons
    FROM pg_constraint
    WHERE conrelid=r.relid AND contype IN ('p','u','c');

    RETURN NEXT FORMAT('DROP TABLE IF EXISTS %I.%I CASCADE;', r.sch, r.tab);
    RETURN NEXT FORMAT('CREATE TABLE %I.%I (%s%s);', r.sch, r.tab, cols, cons);
  END LOOP;

  -- INDEXES (não-PK e não-UNIQUE)
  FOR r IN
    SELECT
      ix.indexrelid                 AS idx_oid,
      ni.nspname                    AS idx_sch,
      ic.relname                    AS idx_name
    FROM pg_index ix
    JOIN pg_class ic ON ic.oid = ix.indexrelid
    JOIN pg_namespace ni ON ni.oid = ic.relnamespace
    JOIN pg_class tc ON tc.oid = ix.indrelid
    JOIN pg_namespace nt ON nt.oid = tc.relnamespace
    WHERE nt.nspname = p_schema
      AND NOT ix.indisprimary
      AND NOT ix.indisunique
  LOOP
    RETURN NEXT FORMAT('DROP INDEX IF EXISTS %I.%I;', r.idx_sch, r.idx_name);
    RETURN NEXT pg_get_indexdef(r.idx_oid) || ';';
  END LOOP;

  -- FOREIGN KEYS
  FOR r IN
    SELECT n.nspname AS sch, c.conname, c.conrelid::regclass AS tbl, pg_get_constraintdef(c.oid, true) AS def
    FROM pg_constraint c
    JOIN pg_namespace n ON n.oid=c.connamespace
    WHERE n.nspname=p_schema AND c.contype='f'
  LOOP
    RETURN NEXT FORMAT('ALTER TABLE %s ADD CONSTRAINT %I %s;', r.tbl, r.conname, r.def);
  END LOOP;

  -- VIEWS (normais/materializadas)
  FOR r IN
    SELECT n.nspname AS sch, c.relname AS vname, c.oid AS oid
    FROM pg_class c
    JOIN pg_namespace n ON n.oid=c.relnamespace
    WHERE n.nspname=p_schema AND c.relkind IN ('v','m')
  LOOP
    RETURN NEXT FORMAT('DROP VIEW IF EXISTS %I.%I CASCADE;', r.sch, r.vname);
    RETURN NEXT FORMAT('CREATE OR REPLACE VIEW %I.%I AS %s;', r.sch, r.vname, pg_get_viewdef(r.oid, true));
  END LOOP;

  RETURN;
END
$$;


SELECT * FROM export_schema('public');
 